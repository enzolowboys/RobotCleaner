/* [
 * First Model of Analysis Requirement
 * 
 */
System robotCleaner

Event usercmd      : usercmd(CMD, TEMP)  		//Can be Start or Stop
Event tempSensor : tempSensor(TEMP)     //Invia la temperatura e l'orario della giornata

Dispatch cmdToLed : cmdToLed(CMD) //On, Off led
Dispatch usercmdMsg : usercmd(CMD, TEMP)
Dispatch tempSensorMsg : tempSensor(TEMP)


Dispatch initCmd : initCmd
Dispatch stopCmd : stopCmd

Context ctxRobotCleaner ip [ host="localhost"   port=8032 ] -g white
EventHandler evh for tempSensor -print {	//event-driven ; no Mqtt support yet
 	forwardEvent mbotcleanercontroller -m tempSensorMsg  	//from event to message
}; 
EventHandler evh2 for usercmd -print {	//event-driven ; no Mqtt support yet
 	forwardEvent mbotcleanercontroller -m usercmdMsg  	//from event to message
};   

QActor mbotcleanercontroller context ctxRobotCleaner {
	
	Plan init normal [
		demo consult("./src/model/robotCleaner.pl");
		println("Robot Ready");
		[!? eval(ge,20,20)]	
			println("Entrato")
		else
			println("Non entrato")
	]
	switchTo waitStart
	
	Plan waitStart []
	transition stopAfter 36000000
		//whenMsg tempSensorMsg -> handletempSensor,
		whenMsg usercmdMsg -> doWork
	finally repeatPlan
	
	/* Il robot parte se è arrivato il messaggio di 'start' e i valori del Sensore (Time e Temperature)
	 * sono nei parametri accettabili.
	 * Si ferma quando arriva un messaggio di 'halt'*/
	 /* Requisiti R-Start, R-TempOk, R-TimeOk, R-Stop*/
	Plan doWork resumeLastPlan [
		printCurrentEvent;
		
		/* 
		actorOp getTime;
		[ ?? actorOpDone( OP, R )]
		* */
	
		addRule curTimeValue(16);
			
		onMsg usercmdMsg : usercmd(start, TEMP) -> ReplaceRule curTemperatureValue(X)  with curTemperatureValue(TEMP);
		onMsg usercmdMsg : usercmd(start, TEMP) -> {
			[!? evalCondition(start)]{
				//forward mbotagent -m initCmd : initCmd;	    //dico alla mbotangent (mind) di fermarsi
				forward ledonmbot -m cmdToLed : cmdToLed(on)
			}
			else
				println("CONDITION OF TIME OR TEMP NOT SATISFIED")
		};
		
		onMsg usercmdMsg : usercmd(halt, TEMP) -> {
			println("STOP");
			forward ledonmbot -m cmdToLed : cmdToLed(off)
		}
		
	]
	switchTo handleConditionStop
	
	Plan handleConditionStop [
		/* 
		actorOp getTime;
		[?? actorOpDone( OP, TIME )]
			ReplaceRule curTimeValue(X)  with curTimeValue(TIME);
		*/
		[!? evalCondition(halt)] {
			println("STOP");
			forward ledonmbot -m cmdToLed : cmdToLed(off)
		}
			
	]
	transition whenTime 10000 -> handleConditionStop
		whenMsg tempSensorMsg -> handletempSensor,
		whenMsg usercmdMsg -> doWork
	finally repeatPlan
	
	/*aggiorniamo il Resource Model con i valori correnti di Time e Temperature*/
	Plan handletempSensor resumeLastPlan[
		printCurrentEvent;
		onMsg tempSensorMsg : tempSensor(TEMP) ->
			ReplaceRule curTemperatureValue(X)  with curTemperatureValue(TEMP)
	]
//TODO: TESTING,FIXED OBSTACLE,QActor Sonar
	
}

//Implementazione del led
QActor ledonmbot context ctxRobotCleaner {
	
	Plan init normal[
		println("Inizializza oggetto led")
		
	]
	switchTo waitCommand
	
	Plan waitCommand[]
	transition stopAfter 3600000
		whenMsg cmdToLed -> doWork
	finally repeatPlan
	
	Plan doWork resumeLastPlan[
		
		onMsg cmdToLed : cmdToLed( on ) -> println("LED ON");
		onMsg cmdToLed : cmdToLed( off ) -> println("LED OFF")
	]
		
		
}






QActor tester context ctxRobotCleaner {
	
	Plan init normal[
		println("Start Test")
	]
	switchTo test
	
	Plan test[
		printCurrentEvent;
		emit usercmd : usercmd(start,24);
		delay 10000;
		emit usercmd : usercmd(halt,"-1")		
	]
}

